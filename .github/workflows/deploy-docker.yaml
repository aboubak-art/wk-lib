on:
  workflow_call:
    inputs:
      app_name:
        required: true
        description: "(mandatory) Application name"
        type: string
      image_tag:
        required: true
        description: "(mandatory) Docker image tag"
        type: string
      context:
        required: true
        description: "(mandatory) Context to use. Available options: [aws, dockerhub]"
        type: string
      with_commit_image:
        required: false
        description: (optional) Commit image to DockerHub
        type: boolean
        default: true
      build-args:
        required: false
        description: (optional) Build arguments
        type: string
        default: ""
      deploy_stage:
        required: true
        description: "(mandatory) Deploy stage"
        type: string
      deploy_port:
        required: true
        description: "(mandatory) Deploy port"
        type: number
      exposed_port:
        required: false
        description: "(optional) Exposed port. Default: 3000"
        type: number
        default: 3000
      deploy_host:
        required: false
        description: "(optional) Deploy host. Default is 127.0.0.1"
        type: string
        default: "127.0.0.1"
      dns_name:
        required: false
        description: "(optional) DNS name. Default is localhost"
        type: string
      run_args:
        required: false
        description: "(optional) Run arguments. Default is empty"
        type: string
        default: ""
      post_run:
        required: false
        description: "(optional) Run any bash script after the container is up"
        type: string
        default: ""

    secrets:
      aws_access_key_id:
        required: false
        description: (optional) AWS access key ID
      aws_secret_access_key:
        required: false
        description: (optional) AWS secret access key
      aws_default_region:
        required: false
        description: (optional) AWS default region
      registry:
        required: false
        description: (optional) AWS ECR URL
      dockerhub_username:
        required: false
        description: (optional) DockerHub username
      dockerhub_password:
        required: false
        description: (optional) DockerHub password
      build_env:
        required: false
        description: (optional) Build environment
      deploy_env:
        required: false
        description: (optional) Deploy environment
      deploy_network:
        required: false
        description: "(optional) Deploy networks. Default: bridge"
      ssh_key:
        required: true
        description: SSH key
      ssh_user:
        required: true
        description: SSH user
      ssh_host:
        required: true
        description: SSH host
      ssh_port:
        required: true
        description: SSH port

env:
  build_env: ${{ secrets.build_env }}

jobs:
  build:
    name: Build and push to ${{ inputs.context }}
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS credentials
        if: ${{ inputs.context == 'aws' }}
        run: |
          mkdir -p ~/.aws || true
          echo "[default]" > ~/.aws/credentials
          echo "aws_access_key_id=${{ secrets.aws_access_key_id }}" >> ~/.aws/credentials
          echo "aws_secret_access_key=${{ secrets.aws_secret_access_key }}" >> ~/.aws/credentials
          echo "region=${{ secrets.aws_default_region }}" > ~/.aws/config
      - name: Login to DockerHub
        if: ${{ inputs.context == 'dockerhub' }}
        run: echo "${{ secrets.dockerhub_password }}" | docker login -u ${{ secrets.dockerhub_username }} --password-stdin
      - name: Login to AWS ECR
        if: ${{ inputs.context == 'aws' }}
        run: |
          aws ecr get-login-password --region ${{ secrets.aws_default_region }} | docker login --username AWS --password-stdin ${{ secrets.registry }}
      - name: Set build environment
        if: ${{ env.build_env }}
        run: |
          cat > .env <<EOF
            ${{ secrets.build_env }}
          EOF
      - name: Build and push Docker image
        run: |
          docker build -t ${{ inputs.app_name }}:${{ inputs.image_tag }} ${{ inputs.build-args }} .
          docker tag ${{ inputs.app_name }}:${{ inputs.image_tag }} ${{ secrets.registry }}/${{ inputs.app_name }}:${{ inputs.image_tag }}
          docker push ${{ secrets.registry }}/${{ inputs.app_name }}:${{ inputs.image_tag }}
      - name: Commit image to DockerHub
        if: ${{ inputs.with_commit_image == true }}
        run: |
          docker tag ${{ inputs.app_name }}:${{ inputs.image_tag }} ${{ secrets.dockerhub_username }}/${{ inputs.app_name }}:${{ inputs.image_tag }}
          docker push ${{ secrets.dockerhub_username }}/${{ inputs.app_name }}:${{ inputs.image_tag }}

  deploy:
    name: Deploy to ${{ inputs.deploy_stage }}
    runs-on: ubuntu-22.04
    needs: build
    environment:
      name: ${{ inputs.deploy_stage }}
      url: https://${{ steps.dns_name.outputs.dns_name }}
    steps:
      - uses: actions/checkout@v4
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh || true
          echo "StrictHostKeyChecking no" >> ~/.ssh/config
      - name: Add SSH key and set permissions
        run: |
          echo "${{ secrets.ssh_key }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
      - name: Creating deploy script
        run: |
          cat <<EOF > deploy_${{ inputs.app_name }}.sh
          #!/bin/bash
          set -e

          IMAGE=${{ secrets.registry }}/${{ inputs.app_name }}:${{ inputs.image_tag }}
          NAME=${{ inputs.app_name }}
          PORT=${{ inputs.deploy_port }}
          NETWORK=${{ secrets.deploy_network || 'bridge' }}
          CONTEXT=${{ inputs.context }}

          echo "ğŸ› ï¸  Deploying application in context: \$CONTEXT"
          if [ "\$CONTEXT" == "aws" ]; then
            echo "ğŸ” Logging in to AWS ECR..."
            aws ecr get-login-password --region ${{ secrets.aws_default_region }} | docker login --username AWS --password-stdin ${{ secrets.registry }}
          fi
          
          if [ "\$CONTEXT" == "dockerhub" ]; then
            echo "ğŸ” Logging in to DockerHub..."
            echo "${{ secrets.dockerhub_password }}" | docker login -u ${{ secrets.dockerhub_username }} --password-stdin
          fi

          echo "ğŸš§ Deploying \$NAME"
          echo "ğŸ“ Checking if a container named '\$NAME' exists..."
          if [ ! "\$(docker container ls -q -f name=\$NAME)" ]; then
            if [ "\$(docker container ls -aq -f status=exited -f name=\$NAME)" ]; then
              echo "ğŸ“ \$NAME has status 'exited', deleting..."
              docker container rm \$NAME
            fi
          else
            echo "ğŸ“ \$NAME found and running, deleting..."
            docker container rm \$(docker container stop \$NAME)
          fi

          echo "ğŸš€ Updating \$NAME..."
          docker pull \$IMAGE
          docker container run --name \$NAME \
            -p ${{ inputs.deploy_host }}:\$PORT:${{ inputs.exposed_port }} \
            --env-file /tmp/.env.\$NAME \
            --network \$NETWORK \
            --restart unless-stopped \
            -d ${{ inputs.run_args }} \
            \$IMAGE

          echo "â™»ï¸ Cleanning..."
          docker container prune -f
          docker image prune -f

          echo "âœ… \$NAME deployed successfully!"
          
          EOF
      - name: add post run script
        if: ${{ inputs.post_run != '' }}
        run: |
          echo "Running post run script..."
          cat <<EOF >> deploy_${{ inputs.app_name }}.sh

          ${{ inputs.post_run }}
          EOF
          echo "Post run script added to deploy_${{ inputs.app_name }}.sh"
      - name: Deploying
        run: |
          cat > /tmp/.env.${{ inputs.app_name }} <<EOF
            ${{ secrets.deploy_env }}
          EOF
          scp -P ${{ secrets.ssh_port }} deploy_${{ inputs.app_name }}.sh ${{ secrets.ssh_user }}@${{ secrets.ssh_host }}:/tmp/deploy_${{ inputs.app_name }}.sh
          scp -P ${{ secrets.ssh_port }} /tmp/.env.${{ inputs.app_name }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }}:/tmp/.env.${{ inputs.app_name }}
          ssh -p ${{ secrets.ssh_port }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} "chmod +x /tmp/deploy_${{ inputs.app_name }}.sh"
          ssh -p ${{ secrets.ssh_port }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} "bash /tmp/deploy_${{ inputs.app_name }}.sh"
      - name: Get DNS name
        id: dns_name
        run: |
          if [ "${{ inputs.dns_name }}" == "" ]; then
            echo "DNS name not provided, using default application name"
            echo "dns_name=${{ inputs.app_name }}.dev-team-everest.xyz" >> $GITHUB_OUTPUT
          else
            echo "dns_name=${{ inputs.dns_name }}" >> $GITHUB_OUTPUT
          fi
      - name: Check if DNS is already configured
        id: dns_check
        run: |
          config_file_exists=$(ssh -o StrictHostKeyChecking=no -p ${{ secrets.ssh_port }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} "test -f /etc/nginx/sites-available/${{ steps.dns_name.outputs.dns_name }} && echo 'true' || echo 'false'")
          if [ "$config_file_exists" == "true" ]; then
            echo "dns_configured=true" >> $GITHUB_OUTPUT
          else
            echo "dns_configured=false" >> $GITHUB_OUTPUT
          fi
      - name: Setup DNS
        if: ${{ steps.dns_check.outputs.dns_configured == 'false' && steps.dns_name.outputs.dns_name != '' }}
        run: |
          dns_name="${{ steps.dns_name.outputs.dns_name }}"
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.ssh_port }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} "
          sudo bash -c \"cat > /etc/nginx/sites-available/${dns_name} << 'EOF'
          server {
            listen 80;
            server_name ${dns_name} www.${dns_name};

            location / {
              proxy_pass http://${{ inputs.deploy_host }}:${{ inputs.deploy_port }};
              proxy_set_header Host \\\$host;
              proxy_set_header X-Real-IP \\\$remote_addr;
              proxy_set_header X-Forwarded-For \\\$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \\\$scheme;
            }
          }
          EOF\"
          sudo ln -sf /etc/nginx/sites-available/${dns_name} /etc/nginx/sites-enabled/
          sudo nginx -t
          sudo systemctl reload nginx
          sudo certbot --nginx -d ${dns_name} --non-interactive --agree-tos
          "
          echo "âœ… DNS setup completed!"
      - name: Cleanup
        run: |
          rm -f deploy_${{ inputs.app_name }}.sh
          rm -f /tmp/.env.${{ inputs.app_name }}
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.ssh_port }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} "rm -f /tmp/deploy_${{ inputs.app_name }}.sh"
          ssh -o StrictHostKeyChecking=no -p ${{ secrets.ssh_port }} ${{ secrets.ssh_user }}@${{ secrets.ssh_host }} "rm -f /tmp/.env.${{ inputs.app_name }}"
          echo "âœ… Cleanup completed!"
      - name: Notify deployment
        run: |
          echo "ğŸš€ Deployment to ${{ inputs.deploy_stage }} completed successfully!"
          echo "ğŸ”— Access your application at https://${{ steps.dns_name.outputs.dns_name }}"
          echo "âœ… Deployment completed!"
